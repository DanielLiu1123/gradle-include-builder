import groovy.json.JsonSlurper

import java.nio.file.Paths

def log = { String message ->
    println("[Include Builder] $message (${rootProject.name})")
}

def execWithOutput = { String command, String dir ->
    def process = command.execute([], new File(dir))
    process.waitFor()
    return process.text.trim()
}

def mustExec = { String command, String dir ->
    def process = command.execute([], new File(dir))
    def output = new StringBuilder()
    def error = new StringBuilder()
    process.waitForProcessOutput(output, error)
    if (process.exitValue() != 0) {
        throw new GradleException("Failed to execute: ${command}, error:\n${error.toString()}")
    }
}

def getPath = { String dir ->
    return dir.startsWith('/') ? dir : Paths.get(rootDir.getAbsolutePath(), dir).normalize().toString()
}

class Config {
    List<Dependency> dependencies // optional

    static class Dependency {
        String path // required
        Git git // optional

        static class Git {
            String url // required
            String branch // optional, one of branch or tag
            String tag // optional, one of branch or tag
        }
    }
}

// Main

def configFile = new File(rootDir, 'include-builder.json')
if (!configFile.exists()) {
    log("include-builder.json not found, skipping")
    return
}

def configObj = new JsonSlurper().parse(configFile) // LazyMap

// read include-builder.json
def config = new Config()
config.dependencies = configObj.dependencies?.collect { dep ->
    def d = new Config.Dependency()
    if (!dep.path) throw new IllegalArgumentException("path is required for dependency: ${dep}")
    if (dep.git && !dep.git.url) throw new IllegalArgumentException("url is required for dependency: ${dep}")
    if (dep.git && dep.git.branch && dep.git.tag) throw new IllegalArgumentException("branch and tag cannot be specified at the same time for dependency: ${dep}")
    d.path = dep.path
    d.git = dep.git ? new Config.Dependency.Git(url: dep.git.url, branch: dep.git.branch, tag: dep.git.tag) : null
    return d
} ?: []

def rootProjectBranch = execWithOutput("git branch --show-current", rootDir.getAbsolutePath())
if (!rootProjectBranch) {
    log("Cannot determine the current branch, skipping checkout")
    log("git status:\n${execWithOutput('git status', rootDir.getAbsolutePath())}")
}

def isCI = System.getenv("CI") == "true" || System.getenv("CI") == "1"

def checkout = { String path, Config.Dependency.Git git ->
    if (git.tag) {
        mustExec("git checkout ${git.tag}", path)
    } else {
        // Use main branch by default
        execWithOutput("git checkout main", path)
        // Try the same branch
        if (rootProjectBranch) {
            execWithOutput("git checkout ${rootProjectBranch}", path)
        }
        // Try specified branch
        if (git.branch) {
            mustExec("git checkout ${git.branch}", path)
        }

        // reset to the latest remote, there may be a force push
        mustExec("git reset --hard origin/${execWithOutput('git branch --show-current', path)}", path)
    }
}

for (def dep : config.dependencies) {
    if (!dep.git) continue

    def path = getPath(dep.path)

    if (new File(path).exists()) {
        if (isCI) {
            // Delete all modifications in the CI environment and pull the latest code
            execWithOutput("git rebase --abort", path)
            execWithOutput("git reset --hard HEAD", path)
            execWithOutput("git fetch -pPt", path)

            checkout(path, dep.git)
        } else {
            // Not a CI environment (local), do nothing
        }
    } else {
        Paths.get(path).getParent().toFile().mkdirs()

        mustExec("git clone ${dep.git.url} ${path}", "/")

        try {
            checkout(path, dep.git)
        } catch (Exception e) {
            Paths.get(path).toFile().deleteDir() // delete the dir if the checkout fails
            throw e
        }
    }
}

if (!config.dependencies.isEmpty()) {
    def dependencies = config.dependencies.collect { dep -> dep.path }
    log("Dependencies: ${dependencies}")
    for (def dep : config.dependencies) {
        def path = getPath(dep.path)

        if (dep.git) {
            if (dep.git.tag) {
                log("Dependency: ${dep.path}, Tag: ${dep.git.tag}")
            } else {
                log("Dependency: ${dep.path}, Branch: ${execWithOutput('git branch --show-current', path)}")
            }
        } else {
            log("Dependency: ${dep.path}")
        }

        includeBuild(path)
    }
}
