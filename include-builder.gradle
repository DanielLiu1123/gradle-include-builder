import groovy.json.JsonSlurper

import java.nio.file.Paths

def log = { String message ->
    println("[Include Builder] $message (${rootProject.name})")
}

def execWithOutput = { String command, String dir ->
    def process = command.execute([], new File(dir))
    process.waitFor()
    return process.text.trim()
}

def execWithExitCode = { String command, String dir ->
    def process = command.execute([], new File(dir))
    process.waitFor()
    return process.exitValue()
}

def getPath = { String dir ->
    return dir.startsWith('/') ? dir : Paths.get(rootDir.getAbsolutePath(), dir).normalize().toString()
}

class Config {
    List<Dependency> dependencies

    static class Dependency {
        String path
        Git git

        static class Git {
            String url
            String branch
            String tag
        }
    }
}

// Main

def configFile = new File(rootDir, 'include-builder.json')
if (!configFile.exists()) {
    log("include-builder.json not found, skipping")
    return
}

def configObj = new JsonSlurper().parse(configFile) // LazyMap

// read include-builder.json
def config = new Config()
config.dependencies = configObj.dependencies?.collect { dep ->
    def d = new Config.Dependency()
    if (!dep.path) throw new IllegalArgumentException("path is required for dependency: ${dep}")
    if (dep.git && !dep.git.url) throw new IllegalArgumentException("url is required for dependency: ${dep}")
    if (dep.git && dep.git.branch && dep.git.tag) throw new IllegalArgumentException("branch and tag cannot be specified at the same time for dependency: ${dep}")
    d.path = dep.path
    d.git = dep.git ? new Config.Dependency.Git(url: dep.git.url, branch: dep.git.branch, tag: dep.git.tag) : null
    return d
} ?: []

def rootProjectBranch = execWithOutput("git branch --show-current", rootDir.getAbsolutePath())

def isCI = System.getenv("CI") == "true" || System.getenv("CI") == "1"

def checkout = { String path, Config.Dependency.Git git ->
    if (git.tag) {
        if (execWithExitCode("git checkout ${git.tag}", path) != 0) {
            throw new GradleException("Tag '${git.tag}' not found in ${path}")
        }
    } else {
        // Use main branch by default
        execWithOutput("git checkout main", path)
        // Try the same branch
        execWithOutput("git checkout ${rootProjectBranch}", path)
        // Try specified branch
        if (git.branch) {
            if (execWithExitCode("git checkout ${git.branch}", path) != 0) {
                throw new GradleException("Branch '${git.branch}' not found in ${path}")
            }
        }

        // reset to the latest remote, there may be a force push
        execWithOutput("git reset --hard origin/${execWithOutput('git branch --show-current', path)}", path)
    }
}

for (def dep : config.dependencies) {
    if (!dep.git) continue

    def path = getPath(dep.path)

    if (new File(path).exists()) {
        if (isCI) {
            // Delete all modifications in the CI environment and pull the latest code
            execWithOutput("git rebase --abort", path)
            execWithOutput("git reset --hard HEAD", path)
            execWithOutput("git fetch -pPt", path)

            checkout(path, dep.git)
        } else {
            // Not a CI environment (local), do nothing
        }
    } else {
        Paths.get(path).getParent().toFile().mkdirs()

        def process = "git clone ${dep.git.url} ${path}".execute([], new File("/"))
        process.waitForProcessOutput(System.out, System.err)
        if (process.exitValue() != 0) {
            throw new GradleException("Failed to clone ${dep.git.url} to ${path}")
        }

        try {
            checkout(path, dep.git)
        } catch (Exception e) {
            Paths.get(path).toFile().deleteDir() // delete the dir if the checkout fails
            throw e
        }
    }
}

if (!config.dependencies.isEmpty()) {
    def dependencies = config.dependencies.collect { dep -> dep.path }
    log("Dependencies: ${dependencies}")
    for (def dep : config.dependencies) {
        def path = getPath(dep.path)

        if (dep.git) {
            if (dep.git.tag) {
                log("Dependency: ${dep.path}, Tag: ${execWithOutput('git describe --tags', path)}")
            } else {
                log("Dependency: ${dep.path}, Branch: ${execWithOutput('git branch --show-current', path)}")
            }
        } else {
            log("Dependency: ${dep.path}")
        }

        includeBuild(path)
    }
}
