import org.yaml.snakeyaml.LoaderOptions
import org.yaml.snakeyaml.Yaml
import org.yaml.snakeyaml.constructor.Constructor

import java.nio.file.Paths

import static java.util.Optional.of
import static java.util.Optional.ofNullable

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath("org.yaml:snakeyaml:2.2")
    }
}

def configNames = ['include-builder.yaml', 'include-builder.yml']
def NOT_GIT_REPOSITORY = "NOT_GIT_REPOSITORY"

def log = { String message ->
    println("[Include Builder] $message (${rootProject.name})")
}

def exec = { String command ->
    log("Execute: $command")
    def process = ["bash", "-c", "$command"].execute()
    process.consumeProcessOutput(System.out, System.err)
    return process.waitFor()
}

def getCurrentBranch = { String dir = null ->
    try {
        return "git ${dir ? "-C $dir" : ""} branch --show-current".execute().text.trim()
    } catch (ignored) {
        return NOT_GIT_REPOSITORY
    }
}

def getAbsolutePath = { String dir ->
    return dir.startsWith('/') ? dir : Paths.get(rootDir.getAbsolutePath(), dir).normalize().toString()
}

def getIncludeBuilderYaml = { String absolutePath ->
    def path = absolutePath ?: rootDir.getAbsolutePath()
    return configNames
            .stream()
            .map { new File(path, it) }
            .filter { it.exists() }
            .findFirst()
            .orElse(null)
}

def getGitPath = { Proj project ->
    return project.git?.path ?: project.git?.url?.split('/')?.last()?.split('\\.')?.first()
}

def getGitBuildPath = { Proj project ->
    return Paths.get(getAbsolutePath(getGitPath(project)), project.git?.buildPath ?: '.').normalize().toString()
}

def cloneProject = { String gitUrl, String dir, String branch = null, String extraArgs = null ->
    def path = getAbsolutePath(dir)
    if (new File(path).exists()) {
        return
    }
    exec "git clone ${branch ? "-b $branch" : ""} ${extraArgs ?: ""} $gitUrl ${path}"
}

def build = { String path ->
    def absolutePath = getAbsolutePath(path)
    log("Include project: $absolutePath")
    includeBuild(absolutePath)
}

def file = getIncludeBuilderYaml()
if (!file?.isFile()) {
    log("include-builder.yaml is missing or not a file, skip")
    return
}

// include-builder.yaml parser
def ibYamlParser = new Yaml(new Constructor(Cfg.class, new LoaderOptions()))

// branch mapping parser
def bmYamlParser = new Yaml()

def cfg = ibYamlParser.load(file.text) as Cfg
def branchMappingDir = cfg.branchMappingDir
def currentBranch = getCurrentBranch()
def branchConfigFile = of(new File("$branchMappingDir/${currentBranch}.yaml")).filter { it.exists() }.orElseGet { new File("$branchMappingDir/${currentBranch}.yml") }
def projectToCfg = branchConfigFile.exists() ? bmYamlParser.load(branchConfigFile.text) : [:] as Map<String, BranchMappingCfg>

cfg.projects.each { project ->

    // dir
    def dirCfg = project.dir
    if (dirCfg) {
        def dirPath = getAbsolutePath(dirCfg.path)
        def targetFile = Paths.get(getAbsolutePath(dirPath), dirCfg.buildPath).normalize().toFile()
        if (!targetFile.exists()) {
            log("$dirPath is not exist, skip")
        } else if (!targetFile.isDirectory()) {
            log("$dirPath is not a directory, skip")
        } else {
            build(targetFile.getAbsolutePath())
        }
        return
    }

    // jar
    def jarCfg = project.jar
    if (jarCfg) {
        def jarFile = new File(getAbsolutePath(jarCfg.path))
        switch (jarCfg.downloadPolicy) {
            case DownloadPolicy.ALWAYS:
                if (jarCfg.url) {
                    jarFile.exists() && jarFile.delete()
                    exec "curl -L --create-dirs -o ${jarFile.getAbsolutePath()} ${jarCfg.url}"
                }
                break
            case DownloadPolicy.IF_NOT_PRESENT:
                if (!jarFile.exists()) {
                    jarCfg.url && exec("curl -L --create-dirs -o ${jarFile.getAbsolutePath()} ${jarCfg.url}")
                }
                break
            default:
                break
        }
        return
    }

    // git
    def relativePath = getGitPath(project)
    if (!relativePath) {
        log("git.path and git.url is missing, skip")
        return
    }

    def projectDir = new File(getAbsolutePath(relativePath))
    if (projectDir.exists()) {
        if (!projectDir.isDirectory()) {
            log("$relativePath is not a directory, skip")
            return
        }
        build(getGitBuildPath(project))
        return
    }

    def gitUrl = project.git?.url
    if (!gitUrl) {
        log("$relativePath is not exist, and git.url is missing, skip")
        return
    }

    def id = project.id ?: relativePath.split('/').last()
    def configuredBranch = projectToCfg[id]?.branch ?: project.git?.branch
    def trySameBranch = ofNullable(project?.git?.trySameBranch).orElse(cfg.trySameBranch)
    def extraArgs = project.git?.extraArgs

    def branchToUse
    if (configuredBranch) {
        branchToUse = configuredBranch
    } else if (trySameBranch
            && currentBranch != NOT_GIT_REPOSITORY
            && exec("git ls-remote --heads --exit-code $gitUrl $currentBranch") == 0) {
        branchToUse = currentBranch
    } else {
        branchToUse = null
    }

    cloneProject(gitUrl, relativePath, branchToUse, extraArgs)

    if (projectDir.exists()) {
        build(getGitBuildPath(project))
    }

}

class Cfg {
    String branchMappingDir = '.branch-mappings'
    Boolean trySameBranch = false
    List<Proj> projects = []
}

class Proj {
    String id
    Git git
    Dir dir
    Jar jar
}

class Git {
    String url
    String branch
    String path
    String buildPath = "."
    Boolean trySameBranch
    String extraArgs
}

class Dir {
    String path
    String buildPath = "."
}

class Jar {
    String url
    String path
    DownloadPolicy downloadPolicy = DownloadPolicy.IF_NOT_PRESENT
}

class BranchMappingCfg {
    String branch
}

enum DownloadPolicy {
    ALWAYS, IF_NOT_PRESENT, NEVER
}